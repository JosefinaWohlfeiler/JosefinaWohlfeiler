####################################   Rqtl


library(qtl)
library(qtl2)

map <- read.cross(format="csvr", dir="/dcdata2/home/josefina/mapping/", file="vrn3_gen.csv", na.strings=".", genotypes=c("a", "h", "b"), alleles=c("a", "b"), estimate.map=FALSE)


#estimate.map=FALSE    Markers will be assigned dummy locations, with no attempt to estimate inter-marker distances

summary(map)
#F2 intercross

    No. individuals:    239 

    No. phenotypes:     1 
    Percent phenotyped: 100 

    No. chromosomes:    9 
        Autosomes:      1 2 3 4 5 6 7 8 9 

    Total markers:      14418 
    No. markers:        1968 1790 1988 1748 1420 1903 1379 1227 995 
    Percent genotyped:  99.7 
    Genotypes (%):      aa:26.2  ab:49.6  bb:24.2  not bb:0.0  not aa:0.0 

nind(map)
#239
nphe(map)
#1
nchr(map)
#9
totmar(map)
#14418

is.list(map)
#[1] TRUE





#graficar los datos faltantes

plotMissing(map)

pdf("missing.pdf")
plotMissing(map)
graphics.off()


############desde mi compu
scp -P 7262 josefina@carrot.vcru.wisc.edu:/dcdata2/home/josefina/mapping/missing.pdf /home/josefina/wisconsin/mapping/plots/missing.pdf





#ntyped        provee el numero de marcadores genotipados para cada individuo (o el numero de individuos genotipados para cada marcador)

#uso de ntyped
#ntyped(cross, what=c("ind","mar"))   #aca le digo si quiero los marcadores para cada individuo (ind) o los individuos para cada marcador (mar)

#La salida es        A vector containing the number of genotypes for each individual or for each marker.


#entonces si hago

ntyped(map, "ind")

#me da un vector de 239 elementos (cant de indiv) indicando cuantos marcadores posee cada individuo del 1 al 239

# [1] 14418 14417 14418 14414 14418 14314 14415 14415 14418 14382 14418 14417
 [13] 14376 14414 14292 14418 14408 14417 14418 14418 14418 14404 14418 14418
 [25] 14415 14380 14418 14415 14418 14416 14373 14352 14417 14418 14418 14412
 [37] 14418 14361 14397 14417 14413 14418 14408 14415 14295 14250 14418 14405
 [49] 14275 14418 14414 14375 14418 14404 14326 14352 14418 14418 14411 14409
 [61] 14417 14408 14417 14417 14418 14221 14417 14418 14306 14404 14418 14384
 [73] 14412 14402 14412 14190 14408 14406 14418 14418 14283 14228 14131 14418
 [85] 14372 14405 14337 14415 14418 14412 14297 14418 14274 14414 14379 14418
 [97] 14408 14418 14396 14403 14380 14359 14416 14361 14390 14371 14417 14418
[109] 14415 14417 14268 14396 14372 14336 14285 14418 14396 14411 14402 14416
[121] 14418 14358 14418 14413 14418 14366 14418 14412 14175 14418 14414 14418
[133] 14418 14409 14406 14125 14416 14418 14414 14416 14325 14414 14315 14412
[145] 14418 14418 14418 14367 14418 14382 14390 14395 14415 14261 14411 14408
[157] 14388 14415 14135 14418 14304 14418 14418 14379 14416 14308 14411 14398
[169] 14418 14418 14413 14402 14351 14416 14416 14413 14418 14407 14326 14410
[181] 14413 14418 14190 14392 14141 14176 14408 14418 14198 14418 14417 14370
[193] 14312 14418 14302 14213 14417 14320 14411 14414 14289 14418 14418 14409
[205] 14416 14418 14418 14412 14338 14303 14416 14418 14069 14330 14385 14369
[217] 14418 14410 14411 14153 14142 14415 14418 14417 14417 14418 14115 14400
[229] 14418 14303 14404 14355 14418 14418 14403 14397 14418 14409 14418


length(ntyped(map, "ind"))
#[1] 239
length(ntyped(map, "mar"))
#[1] 14418




# que me de ahora los faltantes para cada individuo

nmissing(map, "ind")
# [1]   0   1   0   4   0 104   3   3   0  36   0   1  42   4 126   0  10   1
 [19]   0   0   0  14   0   0   3  38   0   3   0   2  45  66   1   0   0   6
 [37]   0  57  21   1   5   0  10   3 123 168   0  13 143   0   4  43   0  14
 [55]  92  66   0   0   7   9   1  10   1   1   0 197   1   0 112  14   0  34
 [73]   6  16   6 228  10  12   0   0 135 190 287   0  46  13  81   3   0   6
 [91] 121   0 144   4  39   0  10   0  22  15  38  59   2  57  28  47   1   0
[109]   3   1 150  22  46  82 133   0  22   7  16   2   0  60   0   5   0  52
[127]   0   6 243   0   4   0   0   9  12 293   2   0   4   2  93   4 103   6
[145]   0   0   0  51   0  36  28  23   3 157   7  10  30   3 283   0 114   0
[163]   0  39   2 110   7  20   0   0   5  16  67   2   2   5   0  11  92   8
[181]   5   0 228  26 277 242  10   0 220   0   1  48 106   0 116 205   1  98
[199]   7   4 129   0   0   9   2   0   0   6  80 115   2   0 349  88  33  49
[217]   0   8   7 265 276   3   0   1   1   0 303  18   0 115  14  63   0   0
[235]  15  21   0   9   0

#  si queremos graficar esto   uso la funcion "par" para hacer una figura con mas de un grafico y luego la funcion "plot" para graficar


#‘las’ numeric in {0,1,2,3}; the style of axis labels.
#          0: always parallel to the axis [_default_],
#          1: always horizontal,
#          2: always perpendicular to the axis,
#          3: always vertical.


#‘mfcol, mfrow’ A vector of the form ‘c(nr, nc)’.  Subsequent
#          figures will be drawn in an ‘nr’-by-‘nc’ array on the device
#          by _columns_ (‘mfcol’), or _rows_ (‘mfrow’), respectively.



par(mfrow=c(1,2), las=1)
plot(ntyped(map), ylab="No. typed markers", main="No. genotypes by individual")
plot(ntyped(map, "mar"), ylab="No. typed individuals", main="No. genotypes by marker")


pdf("ntyped.pdf")

par(mfrow=c(1,2), las=1)
plot(ntyped(map), ylab="No. typed markers", main="No. genotypes by individual")
plot(ntyped(map, "mar"), ylab="No. typed individuals", main="No. genotypes by marker")

graphics.off()


############desde mi compu
scp -P 7262 josefina@carrot.vcru.wisc.edu:/dcdata2/home/josefina/mapping/ntyped-i.pdf /home/josefina/wisconsin/mapping/plots/ntyped-i.pdf








### PARA SACARME LA DUDA HACERLO CON "IND"

plot(ntyped(map, "ind"), ylab="No. typed markers", main="No. genotypes by individual")
pdf("ntyped1.pdf")
plot(ntyped(map, "ind"), ylab="No. typed markers", main="No. genotypes by individual")
graphics.off()


### Y AHORA SIN "IND" (COMO EL PRIMERO) PERO LO HAGO SOLO PARA COMPARAR BIEN

plot(ntyped(map), ylab="No. typed markers", main="No. genotypes by individual")
pdf("ntyped2.pdf")
plot(ntyped(map), ylab="No. typed markers", main="No. genotypes by individual")
graphics.off()

####   RESULTAN SER IGUALES, POR LO TANTO, NO PONER NADA ES LO MISMO QUE PONER "IND". EL QUE CAMBIA ES CUANDO PONGO "MAR"






########     poner los limites de y asi me muestra todos los datos

par(mfrow=c(1,2), las=1)
plot(ntyped(map), ylab="No. typed markers", main="No. genotypes by individual", ylim=c(1000,15000))
plot(ntyped(map, "mar"), ylab="No. typed individuals", main="No. genotypes by marker", ylim=c(0,250))

pdf("ntyped3.pdf")

par(mfrow=c(1,2), las=1)
plot(ntyped(map), ylab="No. typed markers", main="No. genotypes by individual", ylim=c(1000,15000))
plot(ntyped(map, "mar"), ylab="No. typed individuals", main="No. genotypes by marker", ylim=c(0,250))
graphics.off()





##########   solo el de los individuos, acotar la region para verlo mejor

plot(ntyped(map, "mar"), ylab="No. typed individuals", main="No. genotypes by marker", ylim=c(0,250), xlim=c(7000,7200))
pdf("ntyped-i.pdf")
plot(ntyped(map, "mar"), ylab="No. typed individuals", main="No. genotypes by marker", ylim=c(0,250), xlim=c(7000,7200))
graphics.off()



###     LOS GRAFICOS MUESTRAN QUE ESTAN BIEN LOS DATOS, NO SE OBSERVAN MUCHOS DATOS FALTANTES DE GENOTIPADO








#####                omit the individuals with lots of missing genotype data

#        se usa la funcion subset.cross()



# primero explorar

ntyped(map, "ind")   #es lo mismo que ntyped(map)
#me da un vector de 239 elementos (cant de indiv) indicando cuantos marcadores posee cada individuo del 1 al 239


#creo un objeto que me diga, de todos los ntyped(map) (es decir los individuos), cuales son mayores a 14000
v14000 <- ntyped(map)>14000
length(v14000)
#239    # es el total de individuos
head(v14000)
#[1] TRUE TRUE TRUE TRUE TRUE TRUE

# todos son mayores a 14mil    


#####################              entonces no quiero eliminar individuos






#####                omit the markers with lots of missing data


# se usa la funcion     drop.markers()

length(ntyped(map, "mar"))
#[1] 14418

#typed(map, "mar")
#me da un vector de 14418 elementos (cant de marcadores) indicando cuantos individuos estan genotipados en cada marcador

head(ntyped(map, "mar"), n=20)
#1_54682  1_90261  1_97066 1_107507 1_107603 1_174010 1_194221 1_194295 
     237      239      237      239      237      237      237      238 
1_223588 1_223642 1_291256 1_291300 1_305415 1_351514 1_351520 1_382222 
     238      238      237      237      239      238      238      237 
1_396346 1_482195 1_489898 1_489908 
     238      238      239      239 

#creo el elemento de este vector

nt.bymar <- ntyped(map, "mar")

length(nt.bymar)
#[1] 14418
summary(nt.bymar)
#   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
#  237.0   238.0   239.0   238.3   239.0   239.0 

# el minimo es 237, es decir, como minimo hay 237 individuos genotipados en cada marcador


length(nt.bymar[nt.bymar < 238])
#[1] 2639
# significa que hay 2639 marcadores con 237 individuos genotipados, y si los elimino, me quedare con marcadores genotipados en 238 y 239 individuos

length(nt.bymar[nt.bymar < 239])
#[1] 6738
# significa que hay 6738 marcadores con 237 y 238 individuos genotipados, y si los elimino, me quedare con marcadores genotipados en 239 individuos


#si quisiera eliminar marcadores

#creo un vector que voy a eliminar, que contiene los marcadoes que estan genotipados en menos de 238 individuos, en este caso son cero
#todrop <- names(nt.bymar[nt.bymar < 239])
#al usar la funcion "names" me indica solo los nombres de los marcadores

#y luego sobreescribe "map" eliminando los marcadores seleccionados
#map <- drop.markers(map, todrop)

#summary(map)


################   por ahora decidi no eliminar esos marcadores ya que no serian "markers with lots of missing data", es decir, no elimine nada






#########                 Identify duplicate individuals


#in order to reveal pairs with unusually similar genotypes, which may indicate sample duplications or monozygotic twins. In either case, we will want to #remove one individual from each pair.

#we use the function comparegeno to compare the genotypes for all pairs of individuals. The output is a matrix, whose contents are the proportions #of markers at which the pairs have matching genotypes.


cg <- comparegeno(map)

> length(cg)
[1] 57121
> ncol(cg)
[1] 239
> nrow(cg)
[1] 239
> dim(cg)
[1] 239 239
> length(dim(cg))
[1] 2

#me da una matriz 239x239 en la que compara muestra a muestra, cuyo contenido son las proporciones de marcadores en los que los pares tienen #genotipos coincidentes




#funcion "lower.tri" Lower and Upper Triangular Part of a Matrix

     #Returns a matrix of logicals the same size of a given matrix with
     #entries ‘TRUE’ in the lower or upper triangle.
Usage:
     lower.tri(x, diag = FALSE)
     upper.tri(x, diag = FALSE)     
Arguments:
       x: a matrix or other R object with ‘length(dim(x)) == 2’.  For
          back compatibility reasons, when the above is not fulfilled,
          ‘as.matrix(x)’ is called first.
    diag: logical.  Should the diagonal be included?



#########            hago el histograma


#primero solo (hist.pdf) para entender que hace el segundo script, despues con el segundo (hist1.pdf)

hist(cg[lower.tri(cg)], breaks=seq(0, 1, len=101), xlab="No. matching genotypes")
pdf("hist.pdf")
hist(cg[lower.tri(cg)], breaks=seq(0, 1, len=101), xlab="No. matching genotypes")
graphics.off()


#el segundo. Al parecer le agrega una barra debajo indicando donde hay duplicados 

hist(cg[lower.tri(cg)], breaks=seq(0, 1, len=101), xlab="No. matching genotypes")
rug(cg[lower.tri(cg)])
pdf("hist1.pdf")
hist(cg[lower.tri(cg)], breaks=seq(0, 1, len=101), xlab="No. matching genotypes")
rug(cg[lower.tri(cg)])
graphics.off()


############desde mi compu
scp -P 7262 josefina@carrot.vcru.wisc.edu:/dcdata2/home/josefina/mapping/hist1.pdf /home/josefina/wisconsin/mapping/plots/hist1.pdf




#there are some pairs with well over 90% matching genotypes. We may identify these pairs as follows.


wh <- which(cg > 0.9, arr=TRUE)  #arr=TRUE es para que me de los valores creo, o los "valores" de los individuos

wh
#    row col
#153 153 112
#112 112 153

#entiendo que solo los indiv 153 y 112 tienen mas de 90 % de matching genotypes

> ncol(wh)
[1] 2
> nrow(wh)
[1] 2

> wh[,1]
153 112 
153 112 
> wh[,2]
153 112 
112 153 
> is.matrix(wh)
[1] TRUE
> is.array(wh)
[1] TRUE




wh1 <- wh[wh[,1] < wh[,2],]
wh1
#row col 
#112 153 


#We may inspect the genotype matches for this pair with the following.

#funcion "pull.geno"  Pull out the genotype data from a cross object, as a single big matrix. Es decir, extrae la inf de genoma, la cual es una matriz


g <- pull.geno(map)



#ahora le pido que me muestre los valores de esa matriz que corresponden a la fila 112 columna 153 para comparar esos 2 individuos
table(g[112,], g[153,])
#  
       1    2    3
  1 3726  318    6
  2  109 6374   90
  3   10  231 3529

#esto es cuantos marcadores son aa(1), ab(2) y bb(3)

#VER BIEN QUE SIGNIFICA ESTA MATRIZ


#si no pongo arr=TRUE, es decir FALSE, me da esto
wh3 <- which(cg > 0.9)
wh3
#[1] 26682 36440

#recordando con arr=TRUE
wh
#    row col
#153 153 112
#112 112 153


#si quisiera omitir uno de los dos individuos

#map <- subset(map, ind=-wh1[,2])










#          look for duplicate markers (that is, markers with identical genotypes)




#multiple markers with identical genotypes will invariably map to the same location, and so one might as well thin
#out the markers so that there are no such duplicates, as the extra markers simply slow down all of our analyses.

#function     findDupMarkers()    to identify markers with matching genotypes  "Identify sets of markers with identical genotype data"


#Note that the function drop.dupmarkers() is for dropping markers
with matching names, and considers the genotypes only in order to establish consensus
genotypes across the multiple markers with the same name



#exact.only: If TRUE, look only for markers that have matching genotypes
          and the same pattern of missing data; if FALSE, also look for
          cases where the observed genotypes at one marker match those
          at another, and where the first marker has missing genotype
          whenever the genotype for the second marker is missing.
      

dup <- findDupMarkers(map, exact.only=FALSE)

str(dup)

#List of 2963
 $ 1_223588  : chr "1_223642"
 $ 1_291256  : chr "1_291300"
 $ 1_351514  : chr "1_351520"
 $ 1_489898  : chr "1_489908"
 $ 1_640678  : chr "1_640686"
 $ 1_702893  : chr [1:3] "1_702894" "1_702896" "1_702903"
 $ 1_705737  : chr "1_705750"
 $ 1_775131  : chr "1_775146"
 $ 1_1027784 : chr [1:2] "1_1027798" "1_1027842"
 $ 1_1027865 : chr [1:3] "1_1027868" "1_1027900" "1_1027907"
 $ 1_1027938 : chr [1:3] "1_1027956" "1_1027985" "1_1027988"
 $ 1_1063064 : chr [1:2] "1_1063097" "1_1063107"
  [list output truncated]



dup1 <- findDupMarkers(map, exact.only=TRUE)
str(dup1)
#List of 2963  Al parecer me da lo mismo con TRUE o FALSE





#   ahora tengo que usar    drop.dupmarkers()   para eliminarlos

#Drop markers with duplicate names; retaining the first of each set, with consensus genotyps




verbose: If TRUE, print information on the numbers of genotypes and
          markers omitted.  If > 1, give more detailed information on
          genotypes omitted.

Value:

     The input ‘cross’ object, with any duplicate markers omitted
     (except for one).  The marker retained will have consensus
     genotypes; if multiple versions of a marker have different
     genotypes for an individual, they will be replaced by ‘NA’.


map1 <- drop.dupmarkers(map, verbose=TRUE)
#No duplicate markers.    no entiendo por que me dio eso
#voy a tener que eliminarlos de otra manera




#unlist(dup) creates a vector with just the names of the duplicate markers.

list.dup <- unlist(dup)
length(list.dup)
#4031


map.nodup <- drop.markers(map, list.dup)
summary(map.nodup)

 F2 intercross

    No. individuals:    239 

    No. phenotypes:     1 
    Percent phenotyped: 100 

    No. chromosomes:    9 
        Autosomes:      1 2 3 4 5 6 7 8 9 

    Total markers:      10387 
    No. markers:        1443 1307 1388 1229 1018 1387 1010 908 697 
    Percent genotyped:  99.7 
    Genotypes (%):      aa:26.1  ab:49.7  bb:24.1  not bb:0.0  not aa:0.0 


#efectivamente elimino los 4031 marcadores



#                           entonces ahora sigo con      map.nodup




#                 Look for markers with distorted segregation patterns

# existe un mecanismo que hace que pueda haber una transmision desigual de alelos parentales, de los padres a la descendencia

#We expect the genotypes to appear with the frequencies 1:2:1. Moderate departures from these frequencies are not unusual and may indicate the #presence of partially lethal alleles. Gross departures from these frequencies often indicate problematic markers that should be omitted


# use the function geno.table() to inspect the segregation patterns

#It calculates the genotype frequencies and also a P-value for a test of departure from the 1:2:1 expected ratios. We will focus on those
#markers that show significant distortion at the 5% level, after a Bonferroni correction for the multiple tests.

gt <- geno.table(map.nodup)

head(gt)
#        chr missing aa  ab bb not.bb not.aa P.value
1_54682    1       2 44 114 79      0      0 0.00480
1_90261    1       0 77 111 51      0      0 0.03229
1_97066    1       2 84  93 60      0      0 0.00036
1_107507   1       0 75 116 48      0      0 0.04274
1_107603   1       2 83  94 60      0      0 0.00068
1_174010   1       2 85 100 52      0      0 0.00056



pvalue5 <- gt$P.value < 0.05

head(pvalue5)
#[1] TRUE TRUE TRUE TRUE TRUE TRUE

summary(pvalue5)
   Mode   FALSE    TRUE 
logical    4981    5406 



#gt1 es un filtrado de gt (pasa de 10387 marcadores a 1348), hace la correccion de Bonferroni y se queda con muchos menos
#la correccion consiste en dividir alfa por m(el numero de hipotesis), en este caso el total de marcadores.



gt1 <- gt[gt$P.value < 0.05/totmar(map.nodup),]

head(gt1)

          chr missing  aa  ab bb not.bb not.aa  P.value
1_724795    1       0  90 139 10      0      0 9.74e-14
1_724827    1       0  60 179  0      0      0 3.91e-20
1_1169031   1       1  95 101 42      0      0 4.92e-07
1_1211466   1       2 112  86 39      0      0 2.31e-14
1_1550441   1       1 100  99 39      0      0 5.63e-09
1_1889363   1       2  93  98 46      0      0 2.58e-06



> nrow(gt)
[1] 10387
> nrow(gt1)
[1] 1348



pvalue51 <- gt1$P.value < 0.05
summary(pvalue51)
#  Mode    TRUE 
logical    1348 

#con este filtro de gt a gt1 quedan todos menores a 0.05




pvalue.malo <- gt$P.value > 0.05
summary(pvalue.malo)
#   Mode   FALSE    TRUE 
logical    5406    4981 



pvalue.malo1 <- gt1$P.value > 0.05
summary(pvalue.malo1)
#   Mode   FALSE 
logical    1348 

#vuelvo a confirmar que #con este filtro de gt a gt1 quedan todos menores a 0.05





###########################  aca no entiendo por que decide eliminar los de p-value menor a 1e-10

#leer correccion de Bonferroni


##################     CONSULTAR CON ANDRES ANTES DE ELIMINARLOS, ya lo hice pero le puse otro nombre  map.nodup.nodis




#para ver cuantos marcadores serian


todrop <- rownames(gt[gt$P.value < 1e-10,])
> length(todrop)
#[1] 972
# o sea que en el siguiente paso eliminaria 972 marcadores


map.nodup.nodis <- drop.markers(map.nodup, todrop)


summary(map.nodup.nodis)
    F2 intercross

    No. individuals:    239 

    No. phenotypes:     1 
    Percent phenotyped: 100 

    No. chromosomes:    9 
        Autosomes:      1 2 3 4 5 6 7 8 9 

    Total markers:      9415 
    No. markers:        1310 1201 1254 1147 928 1289 914 806 566 
    Percent genotyped:  99.7 
    Genotypes (%):      aa:26.3  ab:47.9  bb:25.8  not bb:0.0  not aa:0.0 




#                Study individuals’ genotype frequencies


#Just as we expect the markers to segregate 1:2:1, we expect the individuals to have genotype frequencies that are in approximately those proportions.




#esto ya lo habia hecho
#g <- pull.geno(map)

#pero lo hago con map filtrado hasta ahora    map.nodup.nodis


g1 <- pull.geno(map.nodup.nodis)


gfreq <- apply(g1, 1, function(a) table(factor(a, levels=1:3)))
gfreq <- t(t(gfreq) / colSums(gfreq))

par(mfrow=c(1,3), las=1)
for(i in 1:3) plot(gfreq[i,], ylab="Genotype frequency", main=c("AA", "AB", "BB")[i], ylim=c(0,1))

pdf("geno-fr-by-ind.pdf")

par(mfrow=c(1,3), las=1)
for(i in 1:3) plot(gfreq[i,], ylab="Genotype frequency", main=c("AA", "AB", "BB")[i], ylim=c(0,1))

graphics.off()



############desde mi compu
scp -P 7262 josefina@carrot.vcru.wisc.edu:/dcdata2/home/josefina/mapping/geno-fr-by-ind.pdf /home/josefina/wisconsin/mapping/plots/geno-fr-by-ind.pdf


# el grafico se ve bien







#####################    antes de seguir con el tutorial que estoy usando,  aca debo ELIMINAR LOS MARCADORES REDUNDANTES

# pero voy a cambiar de directorio en R asi no se me hace lio, dentro de mapping    mapping1


# el ultimo cross file es         map.nodup.nodis


#  entonces primero voy a copiar los files que necesito en otro espacio de trabajo de R

#necesito map.nodup.nodis

#desde

dcdata2/home/josefina/mapping

R

saveRDS(map.nodup.nodis, "map.nodup.nodis.rds")



# y desde aca

dcdata2/home/josefina/mapping/mapping1

#voy a R

map.nodup.nodis1 <- readRDS("/dcdata2/home/josefina/mapping/map.nodup.nodis.rds")

# y ahi me queda copiado en este directorio con el nombre    map.nodup.nodis1


#######################


# una opcion es usar la funcion jittermap, aunque esa funcion no elimina los marcadores redundantes, solo corre los que se solapan

# usar la funcion find_bins() del paquete onemap     	NO SE PUEDE, NO ES COMPATIBLE CON LA CLASE CROSS
library(onemap)
map.nodup.nodis1.binT <- find_bins(map.nodup.nodis1, exact=TRUE) 
#Error in find_bins(map.nodup.nodis1, exact = TRUE) : map.nodup.nodis1 is not an object of class 'onemap'

##################################################################################   funcion reduce_markers() del paquete qtl2

reduce_markers              package:qtl2               R Documentation

Reduce markers to a subset of more-evenly-spaced ones

Description:

     Find the largest subset of markers such that no two adjacent
     markers are separated by less than some distance.

Usage:

     reduce_markers(
       map,
       min_distance = 1,
       weights = NULL,
       max_batch = 10000,
       batch_distance_mult = 1,
       cores = 1
     )
     
Arguments:

     map: A list with each component being a vector with the marker
          positions for a chromosome.

min_distance: Minimum distance between markers.

 weights: A (optional) list of weights on the markers; same size as
          ‘map’.

max_batch: Maximum number of markers to consider in a batch

batch_distance_mult: If working with batches of markers, reduce
          ‘min_distance’ by this multiple.

cores: Number of CPU cores to use, for parallel calculations. (If
          ‘0’, use ‘parallel::detectCores()’.) Alternatively, this can
          be links to a set of cluster sockets, as produced by
          ‘parallel::makeCluster()’.

Details:

     Uses a dynamic programming algorithm to find, for each chromosome,
     the subset of markers for with max(‘weights’) is maximal, subject
     to the constraint that no two adjacent markers may be separated by
     more than ‘min_distance’.

     The computation time for the algorithm grows with like the square
     of the number of markers, like 1 sec for 10k markers but 30 sec
     for 50k markers. If the number of markers on a chromosome is
     greater than ‘max_batch’, the markers are split into batches and
     the algorithm applied to each batch with min_distance smaller by a
     factor ‘min_distance_mult’, and then merged together for one last
     pass.

Value:

     A list like the input ‘map’, but with the selected subset of
     markers.

Examples:

     # read data
     grav2 <- read_cross2(system.file("extdata", "grav2.zip", package="qtl2"))
     
     # grab genetic map
     gmap <- grav2$gmap
     
     # subset to markers that are >= 1 cM apart
     gmap_sub <- reduce_markers(gmap, 1)
     
     # drop all of the other markers from the cross
     markers2keep <- unlist(lapply(gmap_sub, names))
     grav2_sub <- pull_markers(grav2, markers2keep)


###########################################################
library(qtl2)

# primero      Convert a cross object from the R/qtl format to the R/qtl2 format 

map.nodup.nodis2 <- convert2cross2(map.nodup.nodis1)


# grab genetic map
gmap <- map.nodup.nodis2$gmap


# subset to markers that are >= 0.1 cM apart



gmap_sub <- reduce_markers(gmap, 0.1, cores=15)
ummary(gmap_sub)
  Length Class  Mode   
1 377    -none- numeric
2 331    -none- numeric
3 360    -none- numeric
4 296    -none- numeric
5 271    -none- numeric
6 331    -none- numeric
7 247    -none- numeric
8 247    -none- numeric
9 179    -none- numeric




# solo para probar lo hice con 1 cM
gmap_sub1cM <- reduce_markers(gmap, 1, cores=15)
> summary(gmap_sub1cM)
  Length Class  Mode   
1 83     -none- numeric
2 71     -none- numeric
3 80     -none- numeric
4 58     -none- numeric
5 64     -none- numeric
6 62     -none- numeric
7 56     -none- numeric
8 52     -none- numeric
9 50     -none- numeric
# y efectivamente me dio tandas de muchos menos marcadores 




#        drop all of the other markers from the cross


#le aplico la funcion "names" a todos los elementos de "gmap_sub" o sea me quedo solo con los nombres de los marcadores

names <- lapply(gmap_sub, names)


# creo el objeto con los marcadores que quiero dejar
markers2keep <- unlist(names)



#o los dos pasos juntos
markers2keep <- unlist(lapply(gmap_sub, names))

length(markers2keep)
#[1] 2639   es el total de marcadores co el que me voy a quedar



#            dejo solo los marcadores que seleccione en mi objeto cross

#funcion pull_markers()     Drop all but a selected set of markers from the data matrices and genetic maps

map.nodup.nodis2.nr <- pull_markers(map.nodup.nodis2, markers2keep)


summary(map.nodup.nodis2.nr)

Object of class cross2 (crosstype "f2")

Total individuals             239
No. genotyped individuals     239
No. phenotyped individuals    239
No. with both geno & pheno    239

No. phenotypes                  1
No. covariates                  0
No. phenotype covariates        0

No. chromosomes                 9
Total markers                2639

No. markers by chr:
  1   2   3   4   5   6   7   8   9 
377 331 360 296 271 331 247 247 179 




##########################  scripts-mapping2


     
#  usar              map.nodup.nodis2.nr

#  estoy en /mapping/mapping1



#  Study pairwise marker linkages; look for switched alleles


#Function est.rf() is used to estimate the recombination fraction between each pair and to calculate a LOD score for a test of rf =1/2.

#The function markerlrt() behaves just like est.rf(), but uses a general likelihood ratio test in place of the usual test of pairwise linkage.

map.nodup.nodis2.nr.rf <- est.rf(map.nodup.nodis2.nr)

#Error in est.rf(map.nodup.nodis2.nr) : Input should have class "cross".

class(map.nodup.nodis2.nr)
#[1] "cross2"



###############################################################


#### para solucionar esto voy a volver un par de pasos atras  (vuelvo a usar   map.nodup.nodis1   que es un objeto clase "cross"  no "cross2" es #decir antes de convertirlo a cross2

#corroboro
class(map.nodup.nodis1)
#[1] "f2"    "cross"



# yo ya tenia este vector        markers2keep        que es el de los marcadores con los que me quiero quedar

length(markers2keep)
#[1] 2639   es el total de marcadores con el que me voy a quedar



#ahora esto es del paquete qtl
#funcion pull.markers()  (en vez de pull_markers() de qtl2)   Drop all but a selected set of markers


map.nodup.nodis1.nr <- pull.markers(map.nodup.nodis1, markers2keep)

summary(map.nodup.nodis1.nr)
    F2 intercross

    No. individuals:    239 

    No. phenotypes:     1 
    Percent phenotyped: 100 

    No. chromosomes:    9 
        Autosomes:      1 2 3 4 5 6 7 8 9 

    Total markers:      2639 
    No. markers:        377 331 360 296 271 331 247 247 179 
    Percent genotyped:  99.7 
    Genotypes (%):      aa:26.4  ab:47.8  bb:25.9  not bb:0.0  not aa:0.0 


# y me quedo igual que map.nodup.nodis2.nr



################################################



#      ahora si vuelvo a hacer





#  Study pairwise marker linkages; look for switched alleles


#Function est.rf() is used to estimate the recombination fraction between each pair and to calculate a LOD score for a test of rf =1/2.

#The function markerlrt() behaves just like est.rf(), but uses a general likelihood ratio test in place of the usual test of pairwise linkage.

map.nodup.nodis1.nr.rf <- est.rf(map.nodup.nodis1.nr)

#Warning message:
In est.rf(map.nodup.nodis1.nr) : Alleles potentially switched at markers 
  1_54682 1_1228868 1_1485686 1_2598157 1_3554242 1_4689255 1_4993102 1_5099460 1_5452277 1_6569541 1_10143597 1_13209811 1_14180579 1_17309585 1_19226397 1_21979612 1_26378550 1_27459910 1_29165268 1_29699040 1_30674855 1_31047184 1_33380948 1_35685924 1_37041227 1_40323866 1_40614535 1_41410063 1_41612219 1_41669507 1_41776405 1_41882580 1_44286410 1_46974763 1_47535587 1_47603308 1_47862426 1_49063856 1_49215100 1_50352339 1_50700802 1_50767990 2_545381 2_663041 2_1020906 2_2221466 2_2378676 2_7337605 2_8277582 2_8609905 2_10944474 2_13621573 2_15153177 2_15463572 2_16899764 2_17622085 2_18900845 2_21943297 2_22546616 2_25113913 2_26641930 2_28305320 2_28764440 2_31659372 2_31873620 2_34024801 2_35407073 2_40387120 2_41412987 2_41469834 2_42589735 2_42721983 2_42962689 2_43581898 2_43750700 2_43824367 3_96026 3_413905 3_470906 3_789273 3_938924 3_1650094 3_2298345 3_2402300 3_2705038 3_6567451 3_6891916 3_7096280 3_7159772 3_7431959 3_1065717 [... truncated]


#there are numerous markers with likely switched alleles (A ↔ B). 

#This is indicated through pairs of markers that are strongly indicated to be associated but have estimated recombination fractions >>1/2. The #check-Alleles() function gives more detailed information on this issue.


#For each marker, we compare the maximum LOD score for the cases
#     where the estimated recombination fraction > 0.5 to those where
#     r.f. < 0.5.  The function ‘est.rf’ must first be run



#la salida da lo siguiente:
#A data frame containing the flagged markers, having four columns:
#     the marker name, chromosome ID, numeric index within chromosome,
#     and the difference between the maximum two-point LOD score with
#     the alleles switched to that from the original data.


#The final column in the output for a marker, diff.in.max.LOD, is the difference between the maximum LOD score for the cases where the estimated #recombination fraction is > 1/2 and the maximum LOD score for the cases where the estimated recombination fraction is < 1/2.

#There are a large number of markers that are tightly associated with other markers, but with recombination fractions well above 1/2, which #indicates that some markers likely have their alleles switched.


check.alleles <- checkAlleles(map.nodup.nodis1.nr.rf, threshold=5)
nrow(check.alleles)
# 304 la cantidad de marcadores con los alelos posiblemente cambiados

#recordar que por ahora tengo    Total markers:      2639




#                para visualizarlos

#A plot of the LOD scores against the estimated recombination fractions for all marker pairs

#function pull.rf() to pull out the recombination fractions and LOD scores as matrices


rf <- pull.rf(map.nodup.nodis1.nr.rf)
#me da una matriz con todos los rf comparando marcador por marcador

lod <- pull.rf(map.nodup.nodis1.nr.rf, what="lod")
#me da una matriz con todos los LOD scores comparando marcador por marcador

> length(rf)
[1] 6964321
> length(lod)
[1] 6964321
 
# lo anterior tiene sentido porque son matrices de 2639 x 2639


plot(as.numeric(rf), as.numeric(lod), xlab="Recombination fraction", ylab="LOD score")
pdf("LOD-vs-rf.pdf")
plot(as.numeric(rf), as.numeric(lod), xlab="Recombination fraction", ylab="LOD score")
graphics.off()
#esto demoro un poquito


############desde mi compu
scp -P 7262 josefina@carrot.vcru.wisc.edu:/dcdata2/home/josefina/mapping/mapping1/LOD-vs-rf.pdf /home/josefina/wisconsin/mapping/plots1/LOD-vs-rf.pdf


#como es muy pesado para abrir en la compu
#desde toko para visualizar
scp -P 7262 josefina@carrot.vcru.wisc.edu:/dcdata2/home/josefina/mapping/mapping1/LOD-vs-rf.pdf /home/jwohlfeiler/LOD-vs-rf.pdf
display LOD-vs-rf.pdf


# entonces vemos en el grafico que muchos pares de maracdores con LOD scores altos y frecuencias de recombinacion mayores a 1/2

#es decir, no deberia ser una parabola, sino una curva decreciente


#One solution to this problem is to form initial linkage groups, ensuring that markers with rf > 1/2 are placed in different groups. If all goes #well, each chromosome will come out as a pair of linkage groups: one containing markers with correct alleles and another containing markers with #switched alleles.


#  formLinkageGroups() to infer linkage groups. It uses the pairwise linkage results from est.rf()


# The function has two main arguments: max.rf and min.lod

#Two markers will be placed in the same linkage groups if they have estimated recombination fraction ≤ max.rf and LOD score ≥ min.lod.

#The linkage groups are closed via the transitive property. That is, if markers a and b are linked and markers b and c are linked, then all three #are placed in the same linkage group.



lg <- formLinkageGroups(map.nodup.nodis1.nr.rf, max.rf=0.35, min.lod=6)
table(lg[,2])
#  1   2   3   4   5   6   7   8   9  10  11  12  13  14 
590 413 196 191 154 154 152 142 139 130 103 102  94  79 



#The output of formLinkageGroups() is a matrix with two columns: the initial linkage group
#or chromosome for each marker, and then the assigned linkage group, as inferred from the
#pairwise linkage information.



#tengo que seguir jugando con los parametros. deberian darme 18 grupos de ligamiento
#(since there are 9 chromosomes but each will likely be split in two due to the allele switching problem)


lg1 <- formLinkageGroups(map.nodup.nodis1.nr.rf, max.rf=0.35, min.lod=7)
table(lg1[,2])
#lo mismo que lg

lg2 <- formLinkageGroups(map.nodup.nodis1.nr.rf, max.rf=0.35, min.lod=8)
table(lg2[,2])
# 1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17 
248 221 206 196 192 191 154 154 152 142 139 136 130 103 102  94  79 


lg3 <- formLinkageGroups(map.nodup.nodis1.nr.rf, max.rf=0.35, min.lod=9)
table(lg3[,2])
#lo mismo que lg2


lg4 <- formLinkageGroups(map.nodup.nodis1.nr.rf, max.rf=0.35, min.lod=10)
table(lg4[,2])
#lo mismo que lg2 y lg3



# probar bajar rf a 0.25
lg5 <- formLinkageGroups(map.nodup.nodis1.nr.rf, max.rf=0.25, min.lod=8)
table(lg5[,2])
#  1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20 
221 205 196 192 191 154 154 152 142 140 139 135 130 108 103 102  94  79   1   1 


lg6 <- formLinkageGroups(map.nodup.nodis1.nr.rf, max.rf=0.30, min.lod=8)
table(lg6[,2])
#  1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17 
248 221 206 196 192 191 154 154 152 142 139 136 130 103 102  94  79 


#entonces probar rf=0.25 y lod=10
lg7 <- formLinkageGroups(map.nodup.nodis1.nr.rf, max.rf=0.25, min.lod=10)
table(lg7[,2])
#igual que lg5



###########   elijo lg5    max rf=0.25, min lod=8

###  reorganizar marcadores

#Since we are happy with the results, we can reorganize the markers into these inferred linkage groups. 
#We do so with the same function, formLinkageGroups(), via the argument reorgMarkers.


map.nodup.nodis1.nr.rf.reor <- formLinkageGroups(map.nodup.nodis1.nr.rf, max.rf=0.25, min.lod=8, reorgMarkers=TRUE)

summary(map.nodup.nodis1.nr.rf.reor)
#   F2 intercross

    No. individuals:    239 

    No. phenotypes:     1 
    Percent phenotyped: 100 

    No. chromosomes:    20 
        Autosomes:      1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 

    Total markers:      2639 
    No. markers:        221 205 196 192 191 154 154 152 142 140 139 135 130 108 
                        103 102 94 79 1 1 
    Percent genotyped:  99.7 
    Genotypes (%):      aa:26.4  ab:47.8  bb:25.9  not bb:0.0  not aa:0.0 
Warning message:
In summary.cross(map.nodup.nodis1.nr.rf.reor) :
  Some chromosomes > 1000 cM in length; there may be a problem with the genetic map.
  (Perhaps it is in basepairs?)

#              PENSAR SI ESE WARNING MESSAGE TIENE SENTIDO PARA ESTO DE LOS 20 GRUPOS DE LIGAMIENTO



#  ahora visualizo los datos para ver que marcadores comparten el mismo grupo de ligamiento


#          A plot of the pairwise recombination fractions and LOD scores


#el argumento alternate.chrid: If TRUE and more than one chromosome is plotted,
          #alternate the placement of chromosome axis labels, so that
          #they may be more easily distinguished.

plotRF(map.nodup.nodis1.nr.rf.reor, alternate.chrid=TRUE)
pdf("est-rf-and-lod.pdf")
plotRF(map.nodup.nodis1.nr.rf.reor, alternate.chrid=TRUE)
graphics.off()


############desde mi compu
scp -P 7262 josefina@carrot.vcru.wisc.edu:/dcdata2/home/josefina/mapping/mapping1/est-rf-and-lod.pdf /home/josefina/wisconsin/mapping/plots1/est-rf-and-lod.pdf

#como es muy pesado para abrir en la compu
#desde toko para visualizar
scp -P 7262 josefina@carrot.vcru.wisc.edu:/dcdata2/home/josefina/mapping/mapping1/est-rf-and-lod.pdf /home/jwohlfeiler/est-rf-and-lod.pdf
display est-rf-and-lod.pdf




############################################################################################################## hice hasta aca

#esto es del tutorial, yo tengo que ver mi grafico para ver cuales grupos de marcadores estan en el mismo cromosoma
#linkage groups 
1 and 6
2 and 7
3 and 12
4 and 14
5 and 11
8 and 17
9 and 16
10 and 13
18 and 15
are associated with each other, in that they have large LOD scores but their recombinationfractions are not small (the upper-left rectangle for groups 1 and 6 is strongly blue).

#I would infer from this that these markers belong to the same chromosome, but the alleles in one or the other group are switched.



#We can look at this more clearly by picking out a marker from one group and studying the recombination fractions and LOD scores for that marker against all others.

#elijo el tercer marcador del grupo de ligamiento 4


#ya habia hecho esto   rf <- pull.rf(map.nodup.nodis1.nr.rf)   y    lod <- pull.rf(map.nodup.nodis1.nr.rf, what="lod")
#ahora lo hago de nuevo con los datos actualizados

rf1 <- pull.rf(map.nodup.nodis1.nr.rf.reor)

lod1 <- pull.rf(map.nodup.nodis1.nr.rf.reor, what="lod")

mn4 <- markernames(map.nodup.nodis1.nr.rf.reor, chr=4)


par(mfrow=c(2,1))
plot(rf1, mn4[3], bandcol="gray70", ylim=c(0,1), alternate.chrid=TRUE)
abline(h=0.5, lty=2)
plot(lod1, mn4[3], bandcol="gray70", alternate.chrid=TRUE)

pdf("est-rf-and-lod-mn4.pdf")

par(mfrow=c(2,1))
plot(rf1, mn4[3], bandcol="gray70", ylim=c(0,1), alternate.chrid=TRUE)
abline(h=0.5, lty=2)
plot(lod1, mn4[3], bandcol="gray70", alternate.chrid=TRUE)

graphics.off()

############desde mi compu
scp -P 7262 josefina@carrot.vcru.wisc.edu:/dcdata2/home/josefina/mapping/mapping1/est-rf-and-lod-mn4.pdf /home/josefina/wisconsin/mapping/plots1/est-rf-and-lod-mn4.pdf


# se ve claramente que el tercer marcador del cr 4 tiene frec de recombinac menor a 1/2 con respecto a los demas marcadores del cr 4, y mayores a #1/2 con respecto a los marcadores del cr 14 (como habia visto en el grafico).

#podemos ver el problema tambien inspeccionando tablas de two-locus genotypes, producidas por la funcion    geno.crosstab()

# esta funcion da la salida
#A matrix containing the number of individuals having each possible
#     pair of genotypes.  Genotypes for the first marker are in the
#     rows; genotypes for the second marker are in the columns


geno.crosstab(map.nodup.nodis1.nr.rf.reor, mn4[3], mn4[11])
#         4_5744521
4_2002113  - aa ab bb
       -   0  0  0  0
       aa  0 43 21  0
       ab  1  6 95 12
       bb  0  1 20 40

mn14 <- markernames(map.nodup.nodis1.nr.rf.reor, chr=14)
geno.crosstab(map.nodup.nodis1.nr.rf.reor, mn4[3], mn14[11])
#        4_7376003
4_2002113  - aa ab bb
       -   0  0  0  0
       aa  0  1 21 42
       ab  0 18 79 17
       bb  1 37 19  4

#it is clear that, if the genotypes for 4_2002113 are correct, then the A and B alleles for 4_7376003 are switched
# ver de nuevo esto, no entiendo bien la matriz

#we will simply trust that the alleles need to be switched for all of the markers on linkage
#groups 6,7,11-14, 16-18, The function switchAlleles() is convenient for performing the allele switching.


toswitch <- markernames(map.nodup.nodis1.nr.rf.reor, chr=c(6,7,11:14,16:18))

map.nodup.nodis1.nr.rf.reor.sw <- switchAlleles(map.nodup.nodis1.nr.rf.reor, toswitch)




# entonces ahora el plot of recombination fractions and LOD scores va a ser diferente



####  primero tenemos que volver a aplicar la funcion est.rf() despues de haber switched los alelos


map.nodup.nodis1.nr.rf.reor.sw.rf <- est.rf(map.nodup.nodis1.nr.rf.reor.sw)
#Warning message:
In est.rf(map.nodup.nodis1.nr.rf.reor.sw) :
  Alleles potentially switched at markers 
  1_51418423


plotRF(map.nodup.nodis1.nr.rf.reor.sw.rf, alternate.chrid=TRUE)
pdf("est-rf-and-lod-sw.pdf")
plotRF(map.nodup.nodis1.nr.rf.reor.sw.rf, alternate.chrid=TRUE)
graphics.off()

#lo visualizo en Rstudio porque es pesado




## rehacer el grafico de LOD scores versus recombination fractions for all pairs   todavia no lo hagp

rf2 <- pull.rf(map.nodup.nodis1.nr.rf.reor.sw.rf)
lod2 <- pull.rf(map.nodup.nodis1.nr.rf.reor.sw.rf, what="lod")

plot(as.numeric(rf2), as.numeric(lod2), xlab="Recombination fraction", ylab="LOD score")
pdf("LOD-vs-rf-sw.pdf")
plot(as.numeric(rf2), as.numeric(lod2), xlab="Recombination fraction", ylab="LOD score")
graphics.off()

#vemos en este grafico que no hay frecuencias de recombinacion mayores a 1/2, y mientras mayor es la fr, menor es el lod score (que indica # menor ligamiento)







#                          Form linkage groups



#First, we again attempt to infer the linkage groups, with the hope that we’ll come away with exactly 9.


lg8 <- formLinkageGroups(map.nodup.nodis1.nr.rf.reor.sw.rf, max.rf=0.35, min.lod=6)
table(lg8[,2])
# 1   2   3   4   5   6   7   8 
675 361 331 330 270 246 244 182 

lg9 <- formLinkageGroups(map.nodup.nodis1.nr.rf.reor.sw.rf, max.rf=0.35, min.lod=8)
table(lg9[,2])
#  1   2   3   4   5   6   7   8   9  10 
375 360 331 330 300 270 246 244 182   1 


lg10 <- formLinkageGroups(map.nodup.nodis1.nr.rf.reor.sw.rf, max.rf=0.35, min.lod=9)
table(lg10[,2])
#igual que lg9

lg11 <- formLinkageGroups(map.nodup.nodis1.nr.rf.reor.sw.rf, max.rf=0.35, min.lod=10)
table(lg11[,2])
#igual que lg9 y lg10



#elijo lg10    max.rf=0.35, min.lod=9



#Right; we’ve got 9 groups.   Now we reorganize the markers again.

map.nodup.nodis1.nr.rf.reor.sw.rf.lg <- formLinkageGroups(map.nodup.nodis1.nr.rf.reor.sw.rf, max.rf=0.35, min.lod=9, reorgMarkers=TRUE)

#It is useful to plot the pairwise recombination fractions and LOD scores again

plotRF(map.nodup.nodis1.nr.rf.reor.sw.rf.lg)
pdf("lod-vs-rf-nosw.pdf")
plotRF(map.nodup.nodis1.nr.rf.reor.sw.rf.lg)
graphics.off()


#vemos en el grafico que we have 9 clear linkage groups, with markers within a group linked to one another, and markers in distinct groups showing #no evidence of linkage




################   sigue en scripts-mapping3






#################                       ordenar los marcadores cromosoma por cromosoma













     
     
     
     
     
     
     
     
     



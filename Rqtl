####################################   Rqtl


library(qtl)
library(qtl2)

map <- read.cross(format="csvr", dir="/dcdata2/home/josefina/mapping/", file="vrn3_gen.csv", na.strings=".", genotypes=c("a", "h", "b"), alleles=c("a", "b"), estimate.map=FALSE)


#estimate.map=FALSE    Markers will be assigned dummy locations, with no attempt to estimate inter-marker distances

summary(map)
#F2 intercross

    No. individuals:    239 

    No. phenotypes:     1 
    Percent phenotyped: 100 

    No. chromosomes:    9 
        Autosomes:      1 2 3 4 5 6 7 8 9 

    Total markers:      14418 
    No. markers:        1968 1790 1988 1748 1420 1903 1379 1227 995 
    Percent genotyped:  99.7 
    Genotypes (%):      aa:26.2  ab:49.6  bb:24.2  not bb:0.0  not aa:0.0 

nind(map)
#239
nphe(map)
#1
nchr(map)
#9
totmar(map)
#14418

is.list(map)
#[1] TRUE





#graficar los datos faltantes

plotMissing(map)

pdf("missing.pdf")
plotMissing(map)
graphics.off()


############desde mi compu
scp -P 7262 josefina@carrot.vcru.wisc.edu:/dcdata2/home/josefina/mapping/missing.pdf /home/josefina/wisconsin/mapping/plots/missing.pdf





#ntyped        provee el numero de marcadores genotipados para cada individuo (o el numero de individuos genotipados para cada marcador)

#uso de ntyped
#ntyped(cross, what=c("ind","mar"))   #aca le digo si quiero los marcadores para cada individuo (ind) o los individuos para cada marcador (mar)

#La salida es        A vector containing the number of genotypes for each individual or for each marker.


#entonces si hago

ntyped(map, "ind")

#me da un vector de 239 elementos (cant de indiv) indicando cuantos marcadores posee cada individuo del 1 al 239

# [1] 14418 14417 14418 14414 14418 14314 14415 14415 14418 14382 14418 14417
 [13] 14376 14414 14292 14418 14408 14417 14418 14418 14418 14404 14418 14418
 [25] 14415 14380 14418 14415 14418 14416 14373 14352 14417 14418 14418 14412
 [37] 14418 14361 14397 14417 14413 14418 14408 14415 14295 14250 14418 14405
 [49] 14275 14418 14414 14375 14418 14404 14326 14352 14418 14418 14411 14409
 [61] 14417 14408 14417 14417 14418 14221 14417 14418 14306 14404 14418 14384
 [73] 14412 14402 14412 14190 14408 14406 14418 14418 14283 14228 14131 14418
 [85] 14372 14405 14337 14415 14418 14412 14297 14418 14274 14414 14379 14418
 [97] 14408 14418 14396 14403 14380 14359 14416 14361 14390 14371 14417 14418
[109] 14415 14417 14268 14396 14372 14336 14285 14418 14396 14411 14402 14416
[121] 14418 14358 14418 14413 14418 14366 14418 14412 14175 14418 14414 14418
[133] 14418 14409 14406 14125 14416 14418 14414 14416 14325 14414 14315 14412
[145] 14418 14418 14418 14367 14418 14382 14390 14395 14415 14261 14411 14408
[157] 14388 14415 14135 14418 14304 14418 14418 14379 14416 14308 14411 14398
[169] 14418 14418 14413 14402 14351 14416 14416 14413 14418 14407 14326 14410
[181] 14413 14418 14190 14392 14141 14176 14408 14418 14198 14418 14417 14370
[193] 14312 14418 14302 14213 14417 14320 14411 14414 14289 14418 14418 14409
[205] 14416 14418 14418 14412 14338 14303 14416 14418 14069 14330 14385 14369
[217] 14418 14410 14411 14153 14142 14415 14418 14417 14417 14418 14115 14400
[229] 14418 14303 14404 14355 14418 14418 14403 14397 14418 14409 14418


length(ntyped(map, "ind"))
#[1] 239
length(ntyped(map, "mar"))
#[1] 14418




# que me de ahora los faltantes para cada individuo

nmissing(map, "ind")
# [1]   0   1   0   4   0 104   3   3   0  36   0   1  42   4 126   0  10   1
 [19]   0   0   0  14   0   0   3  38   0   3   0   2  45  66   1   0   0   6
 [37]   0  57  21   1   5   0  10   3 123 168   0  13 143   0   4  43   0  14
 [55]  92  66   0   0   7   9   1  10   1   1   0 197   1   0 112  14   0  34
 [73]   6  16   6 228  10  12   0   0 135 190 287   0  46  13  81   3   0   6
 [91] 121   0 144   4  39   0  10   0  22  15  38  59   2  57  28  47   1   0
[109]   3   1 150  22  46  82 133   0  22   7  16   2   0  60   0   5   0  52
[127]   0   6 243   0   4   0   0   9  12 293   2   0   4   2  93   4 103   6
[145]   0   0   0  51   0  36  28  23   3 157   7  10  30   3 283   0 114   0
[163]   0  39   2 110   7  20   0   0   5  16  67   2   2   5   0  11  92   8
[181]   5   0 228  26 277 242  10   0 220   0   1  48 106   0 116 205   1  98
[199]   7   4 129   0   0   9   2   0   0   6  80 115   2   0 349  88  33  49
[217]   0   8   7 265 276   3   0   1   1   0 303  18   0 115  14  63   0   0
[235]  15  21   0   9   0

#  si queremos graficar esto   uso la funcion "par" para hacer una figura con mas de un grafico y luego la funcion "plot" para graficar


#‘las’ numeric in {0,1,2,3}; the style of axis labels.
#          0: always parallel to the axis [_default_],
#          1: always horizontal,
#          2: always perpendicular to the axis,
#          3: always vertical.


#‘mfcol, mfrow’ A vector of the form ‘c(nr, nc)’.  Subsequent
#          figures will be drawn in an ‘nr’-by-‘nc’ array on the device
#          by _columns_ (‘mfcol’), or _rows_ (‘mfrow’), respectively.



par(mfrow=c(1,2), las=1)
plot(ntyped(map), ylab="No. typed markers", main="No. genotypes by individual")
plot(ntyped(map, "mar"), ylab="No. typed individuals", main="No. genotypes by marker")


pdf("ntyped.pdf")

par(mfrow=c(1,2), las=1)
plot(ntyped(map), ylab="No. typed markers", main="No. genotypes by individual")
plot(ntyped(map, "mar"), ylab="No. typed individuals", main="No. genotypes by marker")

graphics.off()


############desde mi compu
scp -P 7262 josefina@carrot.vcru.wisc.edu:/dcdata2/home/josefina/mapping/ntyped-i.pdf /home/josefina/wisconsin/mapping/plots/ntyped-i.pdf








### PARA SACARME LA DUDA HACERLO CON "IND"

plot(ntyped(map, "ind"), ylab="No. typed markers", main="No. genotypes by individual")
pdf("ntyped1.pdf")
plot(ntyped(map, "ind"), ylab="No. typed markers", main="No. genotypes by individual")
graphics.off()


### Y AHORA SIN "IND" (COMO EL PRIMERO) PERO LO HAGO SOLO PARA COMPARAR BIEN

plot(ntyped(map), ylab="No. typed markers", main="No. genotypes by individual")
pdf("ntyped2.pdf")
plot(ntyped(map), ylab="No. typed markers", main="No. genotypes by individual")
graphics.off()

####   RESULTAN SER IGUALES, POR LO TANTO, NO PONER NADA ES LO MISMO QUE PONER "IND". EL QUE CAMBIA ES CUANDO PONGO "MAR"






########     poner los limites de y asi me muestra todos los datos

par(mfrow=c(1,2), las=1)
plot(ntyped(map), ylab="No. typed markers", main="No. genotypes by individual", ylim=c(1000,15000))
plot(ntyped(map, "mar"), ylab="No. typed individuals", main="No. genotypes by marker", ylim=c(0,250))

pdf("ntyped3.pdf")

par(mfrow=c(1,2), las=1)
plot(ntyped(map), ylab="No. typed markers", main="No. genotypes by individual", ylim=c(1000,15000))
plot(ntyped(map, "mar"), ylab="No. typed individuals", main="No. genotypes by marker", ylim=c(0,250))
graphics.off()





##########   solo el de los individuos, acotar la region para verlo mejor

plot(ntyped(map, "mar"), ylab="No. typed individuals", main="No. genotypes by marker", ylim=c(0,250), xlim=c(7000,7200))
pdf("ntyped-i.pdf")
plot(ntyped(map, "mar"), ylab="No. typed individuals", main="No. genotypes by marker", ylim=c(0,250), xlim=c(7000,7200))
graphics.off()



###     LOS GRAFICOS MUESTRAN QUE ESTAN BIEN LOS DATOS, NO SE OBSERVAN MUCHOS DATOS FALTANTES DE GENOTIPADO








#####                omit the individuals with lots of missing genotype data

#        se usa la funcion subset.cross()



# primero explorar

ntyped(map, "ind")   #es lo mismo que ntyped(map)
#me da un vector de 239 elementos (cant de indiv) indicando cuantos marcadores posee cada individuo del 1 al 239


#creo un objeto que me diga, de todos los ntyped(map) (es decir los individuos), cuales son mayores a 14000
v14000 <- ntyped(map)>14000
length(v14000)
#239    # es el total de individuos
head(v14000)
#[1] TRUE TRUE TRUE TRUE TRUE TRUE

# todos son mayores a 14mil    


#####################              entonces no quiero eliminar individuos






#####                omit the markers with lots of missing data


# se usa la funcion     drop.markers()

length(ntyped(map, "mar"))
#[1] 14418

#typed(map, "mar")
#me da un vector de 14418 elementos (cant de marcadores) indicando cuantos individuos estan genotipados en cada marcador

head(ntyped(map, "mar"), n=20)
#1_54682  1_90261  1_97066 1_107507 1_107603 1_174010 1_194221 1_194295 
     237      239      237      239      237      237      237      238 
1_223588 1_223642 1_291256 1_291300 1_305415 1_351514 1_351520 1_382222 
     238      238      237      237      239      238      238      237 
1_396346 1_482195 1_489898 1_489908 
     238      238      239      239 

#creo el elemento de este vector

nt.bymar <- ntyped(map, "mar")

length(nt.bymar)
#[1] 14418
summary(nt.bymar)
#   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
#  237.0   238.0   239.0   238.3   239.0   239.0 

# el minimo es 237, es decir, como minimo hay 237 individuos genotipados en cada marcador


length(nt.bymar[nt.bymar < 238])
#[1] 2639
# significa que hay 2639 marcadores con 237 individuos genotipados, y si los elimino, me quedare con marcadores genotipados en 238 y 239 individuos

length(nt.bymar[nt.bymar < 239])
#[1] 6738
# significa que hay 6738 marcadores con 237 y 238 individuos genotipados, y si los elimino, me quedare con marcadores genotipados en 239 individuos


#si quisiera eliminar marcadores

#creo un vector que voy a eliminar, que contiene los marcadoes que estan genotipados en menos de 238 individuos, en este caso son cero
#todrop <- names(nt.bymar[nt.bymar < 239])
#al usar la funcion "names" me indica solo los nombres de los marcadores

#y luego sobreescribe "map" eliminando los marcadores seleccionados
#map <- drop.markers(map, todrop)

#summary(map)


################   por ahora decidi no eliminar esos marcadores ya que no serian "markers with lots of missing data", es decir, no elimine nada






#########                 Identify duplicate individuals


#in order to reveal pairs with unusually similar genotypes, which may indicate sample duplications or monozygotic twins. In either case, we will want to #remove one individual from each pair.

#we use the function comparegeno to compare the genotypes for all pairs of individuals. The output is a matrix, whose contents are the proportions #of markers at which the pairs have matching genotypes.


cg <- comparegeno(map)

> length(cg)
[1] 57121
> ncol(cg)
[1] 239
> nrow(cg)
[1] 239
> dim(cg)
[1] 239 239
> length(dim(cg))
[1] 2

#me da una matriz 239x239 en la que compara muestra a muestra, cuyo contenido son las proporciones de marcadores en los que los pares tienen #genotipos coincidentes




#funcion "lower.tri" Lower and Upper Triangular Part of a Matrix

     #Returns a matrix of logicals the same size of a given matrix with
     #entries ‘TRUE’ in the lower or upper triangle.
Usage:
     lower.tri(x, diag = FALSE)
     upper.tri(x, diag = FALSE)     
Arguments:
       x: a matrix or other R object with ‘length(dim(x)) == 2’.  For
          back compatibility reasons, when the above is not fulfilled,
          ‘as.matrix(x)’ is called first.
    diag: logical.  Should the diagonal be included?



#########            hago el histograma


#primero solo (hist.pdf) para entender que hace el segundo script, despues con el segundo (hist1.pdf)

hist(cg[lower.tri(cg)], breaks=seq(0, 1, len=101), xlab="No. matching genotypes")
pdf("hist.pdf")
hist(cg[lower.tri(cg)], breaks=seq(0, 1, len=101), xlab="No. matching genotypes")
graphics.off()


#el segundo. Al parecer le agrega una barra debajo indicando donde hay duplicados 

hist(cg[lower.tri(cg)], breaks=seq(0, 1, len=101), xlab="No. matching genotypes")
rug(cg[lower.tri(cg)])
pdf("hist1.pdf")
hist(cg[lower.tri(cg)], breaks=seq(0, 1, len=101), xlab="No. matching genotypes")
rug(cg[lower.tri(cg)])
graphics.off()


############desde mi compu
scp -P 7262 josefina@carrot.vcru.wisc.edu:/dcdata2/home/josefina/mapping/hist1.pdf /home/josefina/wisconsin/mapping/plots/hist1.pdf




#there are some pairs with well over 90% matching genotypes. We may identify these pairs as follows.


wh <- which(cg > 0.9, arr=TRUE)  #arr=TRUE es para que me de los valores creo, o los "valores" de los individuos

wh
#    row col
#153 153 112
#112 112 153

#entiendo que solo los indiv 153 y 112 tienen mas de 90 % de matching genotypes

> ncol(wh)
[1] 2
> nrow(wh)
[1] 2

> wh[,1]
153 112 
153 112 
> wh[,2]
153 112 
112 153 
> is.matrix(wh)
[1] TRUE
> is.array(wh)
[1] TRUE




wh1 <- wh[wh[,1] < wh[,2],]
wh1
#row col 
#112 153 


#We may inspect the genotype matches for this pair with the following.

#funcion "pull.geno"  Pull out the genotype data from a cross object, as a single big matrix. Es decir, extrae la inf de genoma, la cual es una matriz


g <- pull.geno(map)



#ahora le pido que me muestre los valores de esa matriz que corresponden a la fila 112 columna 153 para comparar esos 2 individuos
table(g[112,], g[153,])
#  
       1    2    3
  1 3726  318    6
  2  109 6374   90
  3   10  231 3529

#esto es cuantos marcadores son aa(1), ab(2) y bb(3)

#VER BIEN QUE SIGNIFICA ESTA MATRIZ


#si no pongo arr=TRUE, es decir FALSE, me da esto
wh3 <- which(cg > 0.9)
wh3
#[1] 26682 36440

#recordando con arr=TRUE
wh
#    row col
#153 153 112
#112 112 153


#si quisiera omitir uno de los dos individuos

#map <- subset(map, ind=-wh1[,2])










#          look for duplicate markers (that is, markers with identical genotypes)




#multiple markers with identical genotypes will invariably map to the same location, and so one might as well thin
#out the markers so that there are no such duplicates, as the extra markers simply slow down all of our analyses.

#function     findDupMarkers()    to identify markers with matching genotypes  "Identify sets of markers with identical genotype data"


#Note that the function drop.dupmarkers() is for dropping markers
with matching names, and considers the genotypes only in order to establish consensus
genotypes across the multiple markers with the same name



#exact.only: If TRUE, look only for markers that have matching genotypes
          and the same pattern of missing data; if FALSE, also look for
          cases where the observed genotypes at one marker match those
          at another, and where the first marker has missing genotype
          whenever the genotype for the second marker is missing.
      

dup <- findDupMarkers(map, exact.only=FALSE)

str(dup)

#List of 2963
 $ 1_223588  : chr "1_223642"
 $ 1_291256  : chr "1_291300"
 $ 1_351514  : chr "1_351520"
 $ 1_489898  : chr "1_489908"
 $ 1_640678  : chr "1_640686"
 $ 1_702893  : chr [1:3] "1_702894" "1_702896" "1_702903"
 $ 1_705737  : chr "1_705750"
 $ 1_775131  : chr "1_775146"
 $ 1_1027784 : chr [1:2] "1_1027798" "1_1027842"
 $ 1_1027865 : chr [1:3] "1_1027868" "1_1027900" "1_1027907"
 $ 1_1027938 : chr [1:3] "1_1027956" "1_1027985" "1_1027988"
 $ 1_1063064 : chr [1:2] "1_1063097" "1_1063107"
  [list output truncated]



dup1 <- findDupMarkers(map, exact.only=TRUE)
str(dup1)
#List of 2963  Al parecer me da lo mismo con TRUE o FALSE





#   ahora tengo que usar    drop.dupmarkers()   para eliminarlos

#Drop markers with duplicate names; retaining the first of each set, with consensus genotyps




verbose: If TRUE, print information on the numbers of genotypes and
          markers omitted.  If > 1, give more detailed information on
          genotypes omitted.

Value:

     The input ‘cross’ object, with any duplicate markers omitted
     (except for one).  The marker retained will have consensus
     genotypes; if multiple versions of a marker have different
     genotypes for an individual, they will be replaced by ‘NA’.


map1 <- drop.dupmarkers(map, verbose=TRUE)
#No duplicate markers.    no entiendo por que me dio eso
#voy a tener que eliminarlos de otra manera




#unlist(dup) creates a vector with just the names of the duplicate markers.

list.dup <- unlist(dup)
length(list.dup)
#4031


map.nodup <- drop.markers(map, list.dup)
summary(map.nodup)

 F2 intercross

    No. individuals:    239 

    No. phenotypes:     1 
    Percent phenotyped: 100 

    No. chromosomes:    9 
        Autosomes:      1 2 3 4 5 6 7 8 9 

    Total markers:      10387 
    No. markers:        1443 1307 1388 1229 1018 1387 1010 908 697 
    Percent genotyped:  99.7 
    Genotypes (%):      aa:26.1  ab:49.7  bb:24.1  not bb:0.0  not aa:0.0 


#efectivamente elimino los 4031 marcadores



#                           entonces ahora sigo con      map.nodup




#                 Look for markers with distorted segregation patterns

# existe un mecanismo que hace que pueda haber una transmision desigual de alelos parentales, de los padres a la descendencia

#We expect the genotypes to appear with the frequencies 1:2:1. Moderate departures from these frequencies are not unusual and may indicate the #presence of partially lethal alleles. Gross departures from these frequencies often indicate problematic markers that should be omitted


# use the function geno.table() to inspect the segregation patterns

#It calculates the genotype frequencies and also a P-value for a test of departure from the 1:2:1 expected ratios. We will focus on those
#markers that show significant distortion at the 5% level, after a Bonferroni correction for the multiple tests.

gt <- geno.table(map.nodup)

head(gt)
#        chr missing aa  ab bb not.bb not.aa P.value
1_54682    1       2 44 114 79      0      0 0.00480
1_90261    1       0 77 111 51      0      0 0.03229
1_97066    1       2 84  93 60      0      0 0.00036
1_107507   1       0 75 116 48      0      0 0.04274
1_107603   1       2 83  94 60      0      0 0.00068
1_174010   1       2 85 100 52      0      0 0.00056



pvalue5 <- gt$P.value < 0.05

head(pvalue5)
#[1] TRUE TRUE TRUE TRUE TRUE TRUE

summary(pvalue5)
   Mode   FALSE    TRUE 
logical    4981    5406 



#gt1 es un filtrado de gt (pasa de 10387 marcadores a 1348), hace la correccion de Bonferroni y se queda con muchos menos
#la correccion consiste en dividir alfa por m(el numero de hipotesis), en este caso el total de marcadores.



gt1 <- gt[gt$P.value < 0.05/totmar(map.nodup),]

head(gt1)

          chr missing  aa  ab bb not.bb not.aa  P.value
1_724795    1       0  90 139 10      0      0 9.74e-14
1_724827    1       0  60 179  0      0      0 3.91e-20
1_1169031   1       1  95 101 42      0      0 4.92e-07
1_1211466   1       2 112  86 39      0      0 2.31e-14
1_1550441   1       1 100  99 39      0      0 5.63e-09
1_1889363   1       2  93  98 46      0      0 2.58e-06



> nrow(gt)
[1] 10387
> nrow(gt1)
[1] 1348



pvalue51 <- gt1$P.value < 0.05
summary(pvalue51)
#  Mode    TRUE 
logical    1348 

#con este filtro de gt a gt1 quedan todos menores a 0.05




pvalue.malo <- gt$P.value > 0.05
summary(pvalue.malo)
#   Mode   FALSE    TRUE 
logical    5406    4981 



pvalue.malo1 <- gt1$P.value > 0.05
summary(pvalue.malo1)
#   Mode   FALSE 
logical    1348 

#vuelvo a confirmar que #con este filtro de gt a gt1 quedan todos menores a 0.05





###########################  aca no entiendo por que decide eliminar los de p-value menor a 1e-10

#leer correccion de Bonferroni


##################     CONSULTAR CON ANDRES ANTES DE ELIMINARLOS, ya lo hice pero le puse otro nombre  map.nodup.nodis




#para ver cuantos marcadores serian


todrop <- rownames(gt[gt$P.value < 1e-10,])
> length(todrop)
#[1] 972
# o sea que en el siguiente paso eliminaria 972 marcadores


map.nodup.nodis <- drop.markers(map.nodup, todrop)


summary(map.nodup.nodis)
    F2 intercross

    No. individuals:    239 

    No. phenotypes:     1 
    Percent phenotyped: 100 

    No. chromosomes:    9 
        Autosomes:      1 2 3 4 5 6 7 8 9 

    Total markers:      9415 
    No. markers:        1310 1201 1254 1147 928 1289 914 806 566 
    Percent genotyped:  99.7 
    Genotypes (%):      aa:26.3  ab:47.9  bb:25.8  not bb:0.0  not aa:0.0 




#                Study individuals’ genotype frequencies


#Just as we expect the markers to segregate 1:2:1, we expect the individuals to have genotype frequencies that are in approximately those proportions.




#esto ya lo habia hecho
#g <- pull.geno(map)

#pero lo hago con map filtrado hasta ahora    map.nodup.nodis


g1 <- pull.geno(map.nodup.nodis)


gfreq <- apply(g1, 1, function(a) table(factor(a, levels=1:3)))
gfreq <- t(t(gfreq) / colSums(gfreq))

par(mfrow=c(1,3), las=1)
for(i in 1:3) plot(gfreq[i,], ylab="Genotype frequency", main=c("AA", "AB", "BB")[i], ylim=c(0,1))

pdf("geno-fr-by-ind.pdf")

par(mfrow=c(1,3), las=1)
for(i in 1:3) plot(gfreq[i,], ylab="Genotype frequency", main=c("AA", "AB", "BB")[i], ylim=c(0,1))

graphics.off()



############desde mi compu
scp -P 7262 josefina@carrot.vcru.wisc.edu:/dcdata2/home/josefina/mapping/geno-fr-by-ind.pdf /home/josefina/wisconsin/mapping/plots/geno-fr-by-ind.pdf


# el grafico se ve bien







#####################    antes de seguir con el tutorial que estoy usando,  aca debo ELIMINAR LOS MARCADORES REDUNDANTES

# pero voy a cambiar de directorio en R asi no se me hace lio, dentro de mapping    mapping1


# el ultimo cross file es         map.nodup.nodis


#  entonces primero voy a copiar los files que necesito en otro espacio de trabajo de R

#necesito map.nodup.nodis

#desde

dcdata2/home/josefina/mapping

R

saveRDS(map.nodup.nodis, "map.nodup.nodis.rds")



# y desde aca

dcdata2/home/josefina/mapping/mapping1

#voy a R

map.nodup.nodis1 <- readRDS("/dcdata2/home/josefina/mapping/map.nodup.nodis.rds")

# y ahi me queda copiado en este directorio con el nombre    map.nodup.nodis1


#######################


# una opcion es usar la funcion jittermap, aunque esa funcion no elimina los marcadores redundantes, solo corre los que se solapan

# usar la funcion find_bins() del paquete onemap     	NO SE PUEDE, NO ES COMPATIBLE CON LA CLASE CROSS
library(onemap)
map.nodup.nodis1.binT <- find_bins(map.nodup.nodis1, exact=TRUE) 
#Error in find_bins(map.nodup.nodis1, exact = TRUE) : map.nodup.nodis1 is not an object of class 'onemap'

##################################################################################   funcion reduce_markers() del paquete qtl2

reduce_markers              package:qtl2               R Documentation

Reduce markers to a subset of more-evenly-spaced ones

Description:

     Find the largest subset of markers such that no two adjacent
     markers are separated by less than some distance.

Usage:

     reduce_markers(
       map,
       min_distance = 1,
       weights = NULL,
       max_batch = 10000,
       batch_distance_mult = 1,
       cores = 1
     )
     
Arguments:

     map: A list with each component being a vector with the marker
          positions for a chromosome.

min_distance: Minimum distance between markers.

 weights: A (optional) list of weights on the markers; same size as
          ‘map’.

max_batch: Maximum number of markers to consider in a batch

batch_distance_mult: If working with batches of markers, reduce
          ‘min_distance’ by this multiple.

cores: Number of CPU cores to use, for parallel calculations. (If
          ‘0’, use ‘parallel::detectCores()’.) Alternatively, this can
          be links to a set of cluster sockets, as produced by
          ‘parallel::makeCluster()’.

Details:

     Uses a dynamic programming algorithm to find, for each chromosome,
     the subset of markers for with max(‘weights’) is maximal, subject
     to the constraint that no two adjacent markers may be separated by
     more than ‘min_distance’.

     The computation time for the algorithm grows with like the square
     of the number of markers, like 1 sec for 10k markers but 30 sec
     for 50k markers. If the number of markers on a chromosome is
     greater than ‘max_batch’, the markers are split into batches and
     the algorithm applied to each batch with min_distance smaller by a
     factor ‘min_distance_mult’, and then merged together for one last
     pass.

Value:

     A list like the input ‘map’, but with the selected subset of
     markers.

Examples:

     # read data
     grav2 <- read_cross2(system.file("extdata", "grav2.zip", package="qtl2"))
     
     # grab genetic map
     gmap <- grav2$gmap
     
     # subset to markers that are >= 1 cM apart
     gmap_sub <- reduce_markers(gmap, 1)
     
     # drop all of the other markers from the cross
     markers2keep <- unlist(lapply(gmap_sub, names))
     grav2_sub <- pull_markers(grav2, markers2keep)


###########################################################
library(qtl2)

# primero      Convert a cross object from the R/qtl format to the R/qtl2 format 

map.nodup.nodis2 <- convert2cross2(map.nodup.nodis1)


# grab genetic map
gmap <- map.nodup.nodis2$gmap


# subset to markers that are >= 0.1 cM apart



gmap_sub <- reduce_markers(gmap, 0.1, cores=15)
ummary(gmap_sub)
  Length Class  Mode   
1 377    -none- numeric
2 331    -none- numeric
3 360    -none- numeric
4 296    -none- numeric
5 271    -none- numeric
6 331    -none- numeric
7 247    -none- numeric
8 247    -none- numeric
9 179    -none- numeric




# solo para probar lo hice con 1 cM
gmap_sub1cM <- reduce_markers(gmap, 1, cores=15)
> summary(gmap_sub1cM)
  Length Class  Mode   
1 83     -none- numeric
2 71     -none- numeric
3 80     -none- numeric
4 58     -none- numeric
5 64     -none- numeric
6 62     -none- numeric
7 56     -none- numeric
8 52     -none- numeric
9 50     -none- numeric
# y efectivamente me dio tandas de muchos menos marcadores 




#        drop all of the other markers from the cross


#le aplico la funcion "names" a todos los elementos de "gmap_sub" o sea me quedo solo con los nombres de los marcadores

names <- lapply(gmap_sub, names)


# creo el objeto con los marcadores que quiero dejar
markers2keep <- unlist(names)



#o los dos pasos juntos
markers2keep <- unlist(lapply(gmap_sub, names))

length(markers2keep)
#[1] 2639   es el total de marcadores co el que me voy a quedar



#            dejo solo los marcadores que seleccione en mi objeto cross

#funcion pull_markers()     Drop all but a selected set of markers from the data matrices and genetic maps

map.nodup.nodis2.nr <- pull_markers(map.nodup.nodis2, markers2keep)


summary(map.nodup.nodis2.nr)

Object of class cross2 (crosstype "f2")

Total individuals             239
No. genotyped individuals     239
No. phenotyped individuals    239
No. with both geno & pheno    239

No. phenotypes                  1
No. covariates                  0
No. phenotype covariates        0

No. chromosomes                 9
Total markers                2639

No. markers by chr:
  1   2   3   4   5   6   7   8   9 
377 331 360 296 271 331 247 247 179 




##########################     sigue en scripts-mapping2


#  Study pairwise marker linkages; look for switched alleles    
     
#  usar              map.nodup.nodis2.nr




     
     
     
     
     
     
     
     
     


